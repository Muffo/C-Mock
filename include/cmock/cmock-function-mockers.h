// This file was GENERATED by command:
//     pump.py cmock-function-mockers.h.pump
// DO NOT EDIT BY HAND!!!

// Copyright 2013, Hubert Jagodziński
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Author: hubert.jagodzinski@gmail.com (Hubert Jagodziński)

// C Mock - extension to Google Mock framework allowing for writing C mock
// functions.
//
// This file implements C function mockers of various arities.

#ifndef CMOCK_INCLUDE_CMOCK_CMOCK_FUNCTION_MOCKERS_H_
#define CMOCK_INCLUDE_CMOCK_CMOCK_FUNCTION_MOCKERS_H_

#include <dlfcn.h>

#include <sstream>
#include <stdexcept>

#define MOCK_FUNCTION0(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()() { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 0, \
             this_method_does_not_take_0_arguments); \
             GMOCK_MOCKER_(0,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(0,, n).Invoke(); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func() { \
            GMOCK_MOCKER_(0,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(0,, n).With(); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call() \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(); \
            } \
\
            return real(); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(0,, n); \
\
        friend GMOCK_RESULT_(, F) n(); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n() { \
    return c::call(); \
}

#define MOCK_FUNCTION1(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 1, \
             this_method_does_not_take_1_argument); \
             GMOCK_MOCKER_(1,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(1,, n).Invoke(cmock_a1); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1) { \
            GMOCK_MOCKER_(1,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(1,, n).With(cmock_a1); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1); \
            } \
\
            return real(cmock_a1); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(1,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1) { \
    return c::call(cmock_a1); \
}

#define MOCK_FUNCTION2(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 2, \
             this_method_does_not_take_2_arguments); \
             GMOCK_MOCKER_(2,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(2,, n).Invoke(cmock_a1, cmock_a2); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2) { \
            GMOCK_MOCKER_(2,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(2,, n).With(cmock_a1, cmock_a2); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2); \
            } \
\
            return real(cmock_a1, cmock_a2); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(2,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2) { \
    return c::call(cmock_a1, cmock_a2); \
}

#define MOCK_FUNCTION3(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 3, \
             this_method_does_not_take_3_arguments); \
             GMOCK_MOCKER_(3,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(3,, n).Invoke(cmock_a1, cmock_a2, cmock_a3); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3) { \
            GMOCK_MOCKER_(3,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(3,, n).With(cmock_a1, cmock_a2, cmock_a3); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(3,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3); \
}

#define MOCK_FUNCTION4(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 4, \
             this_method_does_not_take_4_arguments); \
             GMOCK_MOCKER_(4,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(4,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4) { \
            GMOCK_MOCKER_(4,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(4,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(4,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
    4) cmock_a4) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4); \
}

#define MOCK_FUNCTION5(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 5, \
             this_method_does_not_take_5_arguments); \
             GMOCK_MOCKER_(5,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(5,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4, cmock_a5); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5) { \
            GMOCK_MOCKER_(5,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(5,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(5,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5); \
}

#define MOCK_FUNCTION6(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
        GMOCK_ARG_(, F, 6) cmock_a6); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 6, \
             this_method_does_not_take_6_arguments); \
             GMOCK_MOCKER_(6,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(6,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4, cmock_a5, cmock_a6); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5, GMOCK_MATCHER_(, F, \
            6) cmock_a6) { \
            GMOCK_MOCKER_(6,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(6,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5, cmock_a6); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5, cmock_a6); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
                cmock_a6); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(6,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, \
            6) cmock_a6); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, 6) cmock_a6) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
        cmock_a6); \
}

#define MOCK_FUNCTION7(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
        GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 7, \
             this_method_does_not_take_7_arguments); \
             GMOCK_MOCKER_(7,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(7,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4, cmock_a5, cmock_a6, cmock_a7); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5, GMOCK_MATCHER_(, F, \
            6) cmock_a6, GMOCK_MATCHER_(, F, 7) cmock_a7) { \
            GMOCK_MOCKER_(7,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(7,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5, cmock_a6, cmock_a7); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5, cmock_a6, cmock_a7); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
                cmock_a6, cmock_a7); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(7,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, \
            6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, \
    7) cmock_a7) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
        cmock_a6, cmock_a7); \
}

#define MOCK_FUNCTION8(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
        GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
        GMOCK_ARG_(, F, 8) cmock_a8); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 8, \
             this_method_does_not_take_8_arguments); \
             GMOCK_MOCKER_(8,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(8,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5, GMOCK_MATCHER_(, F, \
            6) cmock_a6, GMOCK_MATCHER_(, F, 7) cmock_a7, GMOCK_MATCHER_(, F, \
            8) cmock_a8) { \
            GMOCK_MOCKER_(8,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(8,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5, cmock_a6, cmock_a7, cmock_a8); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
                cmock_a6, cmock_a7, cmock_a8); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(8,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, \
            6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, GMOCK_ARG_(, F, \
            8) cmock_a8); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, \
    7) cmock_a7, GMOCK_ARG_(, F, 8) cmock_a8) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
        cmock_a6, cmock_a7, cmock_a8); \
}

#define MOCK_FUNCTION9(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
        GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
        GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 9, \
             this_method_does_not_take_9_arguments); \
             GMOCK_MOCKER_(9,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(9,, n).Invoke(cmock_a1, cmock_a2, cmock_a3, \
                 cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8, cmock_a9); \
                 \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5, GMOCK_MATCHER_(, F, \
            6) cmock_a6, GMOCK_MATCHER_(, F, 7) cmock_a7, GMOCK_MATCHER_(, F, \
            8) cmock_a8, GMOCK_MATCHER_(, F, 9) cmock_a9) { \
            GMOCK_MOCKER_(9,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(9,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8, cmock_a9); \
                \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5, cmock_a6, cmock_a7, cmock_a8, cmock_a9); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
                cmock_a6, cmock_a7, cmock_a8, cmock_a9); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(9,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, \
            6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, GMOCK_ARG_(, F, \
            8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, \
    7) cmock_a7, GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, \
    9) cmock_a9) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
        cmock_a6, cmock_a7, cmock_a8, cmock_a9); \
}

#define MOCK_FUNCTION10(c, n, F) \
class c \
{ \
    typedef GMOCK_RESULT_(, F) (*func_type)(GMOCK_ARG_(, F, 1) cmock_a1, \
        GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
        GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
        GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
        GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9, \
        GMOCK_ARG_(, F, 10) cmock_a10); \
\
    public: \
        static func_type real; \
\
        c() { \
            mock = this; \
        } \
\
        ~c() { \
            mock = NULL; \
        } \
\
        GMOCK_RESULT_(, F) operator()(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9, \
            GMOCK_ARG_(, F, 10) cmock_a10) { \
            GTEST_COMPILE_ASSERT_(::std::tr1::tuple_size< \
            ::testing::internal::Function<F>::ArgumentTuple>::value == 10, \
             this_method_does_not_take_10_arguments); \
             GMOCK_MOCKER_(10,, n).SetOwnerAndName(this, #n); \
             return GMOCK_MOCKER_(10,, n).Invoke(cmock_a1, cmock_a2, \
                 cmock_a3, cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8, \
                 cmock_a9, cmock_a10); \
        } \
\
        ::testing::MockSpec<F>& \
        cmock_func(GMOCK_MATCHER_(, F, 1) cmock_a1, GMOCK_MATCHER_(, F, \
            2) cmock_a2, GMOCK_MATCHER_(, F, 3) cmock_a3, GMOCK_MATCHER_(, F, \
            4) cmock_a4, GMOCK_MATCHER_(, F, 5) cmock_a5, GMOCK_MATCHER_(, F, \
            6) cmock_a6, GMOCK_MATCHER_(, F, 7) cmock_a7, GMOCK_MATCHER_(, F, \
            8) cmock_a8, GMOCK_MATCHER_(, F, 9) cmock_a9, GMOCK_MATCHER_(, F, \
            10) cmock_a10) { \
            GMOCK_MOCKER_(10,, n).RegisterOwner(this); \
            return GMOCK_MOCKER_(10,, n).With(cmock_a1, cmock_a2, cmock_a3, \
                cmock_a4, cmock_a5, cmock_a6, cmock_a7, cmock_a8, cmock_a9, \
                cmock_a10); \
        } \
\
    private: \
        static func_type lookup() { \
            func_type real = (func_type)dlsym(RTLD_NEXT, #n); \
            if (real == NULL) \
            { \
                std::ostringstream msg; \
                msg << "unable to load "; \
                msg << #n; \
                msg << " function symbol"; \
                throw std::logic_error(msg.str()); \
            } \
            return real; \
        } \
\
        static GMOCK_RESULT_(, F) call(GMOCK_ARG_(, F, 1) cmock_a1, \
            GMOCK_ARG_(, F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, \
            GMOCK_ARG_(, F, 4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, \
            GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, \
            GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9, \
            GMOCK_ARG_(, F, 10) cmock_a10) \
        { \
            if (mock != NULL) \
            { \
                return (*mock)(cmock_a1, cmock_a2, cmock_a3, cmock_a4, \
                    cmock_a5, cmock_a6, cmock_a7, cmock_a8, cmock_a9, \
                    cmock_a10); \
            } \
\
            return real(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
                cmock_a6, cmock_a7, cmock_a8, cmock_a9, cmock_a10); \
        } \
\
        static c *mock; \
\
        mutable ::testing::FunctionMocker<F> GMOCK_MOCKER_(10,, n); \
\
        friend GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, \
            F, 2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, \
            4) cmock_a4, GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, \
            6) cmock_a6, GMOCK_ARG_(, F, 7) cmock_a7, GMOCK_ARG_(, F, \
            8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9, GMOCK_ARG_(, F, \
            10) cmock_a10); \
}; \
\
c *c::mock; \
c::func_type c::real = lookup(); \
\
GMOCK_RESULT_(, F) n(GMOCK_ARG_(, F, 1) cmock_a1, GMOCK_ARG_(, F, \
    2) cmock_a2, GMOCK_ARG_(, F, 3) cmock_a3, GMOCK_ARG_(, F, 4) cmock_a4, \
    GMOCK_ARG_(, F, 5) cmock_a5, GMOCK_ARG_(, F, 6) cmock_a6, GMOCK_ARG_(, F, \
    7) cmock_a7, GMOCK_ARG_(, F, 8) cmock_a8, GMOCK_ARG_(, F, 9) cmock_a9, \
    GMOCK_ARG_(, F, 10) cmock_a10) { \
    return c::call(cmock_a1, cmock_a2, cmock_a3, cmock_a4, cmock_a5, \
        cmock_a6, cmock_a7, cmock_a8, cmock_a9, cmock_a10); \
}

#endif // CMOCK_INCLUDE_CMOCK_CMOCK_FUNCTION_MOCKERS_H_
